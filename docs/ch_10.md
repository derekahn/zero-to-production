# Chapter 10 - Securing Our API

Problem:

Anyone can hit the API and broadcast whatever they want to our entire mailing list.

- base64-encoding ensures that all the characters in the output are ASCII, but it doesn't provide any kind of protection
  - decoding requires no secrets; It's not encrypted!

## Using A Cryptographic Hash

tldr; Hash all stored passwords!

> Assuming that the input space is finite (i.e. password length is capped),
> it is theoretically possible to find a perfect hash function -
> f(x) == f(y) implies x == y.

## Preimage Attack

tldr; SHA3-256 is pretty safe.

- To brute-force it, it's a `2^n` where n is the hash length in bits.
- Typically if `n > 128`, it's considered unfeasible to compute unless a vulnerability is found in SHA3

## Argon2

- Use `Argon2id` with a minimum configuration of 15 MiB of memory, an iteration count of 2, and 1 degree of parallelism.
- If `Argon2id` is not available, use `bcrypt` with a work factor of 10 or more and with a password limit of 72 bytes.
- For legacy systems using `scrypt`, use a minimum CPU/memory cost parameter of (2^16), a minimum block size of 8 (1024 bytes), and a parallelization parameter of 1.
- If `FIPS-140` compliance is required, use `PBKDF2` with a work factor of 310,000 or more and set with an internal hash function of `HMAC-SHA-256`.
- Consider using a pepper to provide additional defense in depth (though alone, it provides no additional secure characteristics).

All the options are designed to be computationally intensive.

> This back-of-the-envelope calculation should make it clear that using a randomly-generated
> password provides you, as a user, with a significant level of protection against brute-force
> attacks even if the server is using fast hashing algorithms for password storage.
> Consistent usage of a password manager is indeed one of the easiest ways to boost your security profile.

## Salting

- `Argon2` is a lot slower than `SHA-3` but this is not enough to make a dictionary attack unfeasible.
- It takes longer to hash the most common 10 million passwords

**salting** is where we add a _unique_ random string to the password before the hash

- The **salt** is stored next to the password hash, in our database.
- If an attacker gets their hands on a databse backup, they will have access to all **salts**.
- But even with access to the **salts**, they'll still have to re-compute; `dictionary_size * n_users`

- OWASP recommends an additional layer of defence - **peppering**
  - All hashes stored in the database are encrypted using a shared secret, only known to the application.
  - However, encryption brings forth another set of challenges:
    - where are we going to store the key?
    - How do we rotate it?
    - Usually a Hardware Security Module (HSM) or a secret vault is used

## ðŸ“¦ Used

- [base64](https://crates.io/crates/base64)
- [sha3](https://crates.io/crates/sha3)

## References

- [how many passwords average person](https://tech.co/password-managers/how-many-passwords-average-person)
- [how to fake a fingerprint and break into a phone](https://www.youtube.com/watch?v=tj2Ty7WkGqk)
- [Pefect Hash Function](https://en.wikipedia.org/wiki/Perfect_hash_function)
