# Chapter 10 - Securing Our API

Problem:

Anyone can hit the API and broadcast whatever they want to our entire mailing list.

- base64-encoding ensures that all the characters in the output are ASCII, but it doesn't provide any kind of protection
  - decoding requires no secrets; It's not encrypted!

## Using A Cryptographic Hash

tldr; Hash all stored passwords!

> Assuming that the input space is finite (i.e. password length is capped),
> it is theoretically possible to find a perfect hash function -
> f(x) == f(y) implies x == y.

## Preimage Attack

tldr; SHA3-256 is pretty safe.

- To brute-force it, it's a `2^n` where n is the hash length in bits.
- Typically if `n > 128`, it's considered unfeasible to compute unless a vulnerability is found in SHA3

## Argon2

- Use `Argon2id` with a minimum configuration of 15 MiB of memory, an iteration count of 2, and 1 degree of parallelism.
- If `Argon2id` is not available, use `bcrypt` with a work factor of 10 or more and with a password limit of 72 bytes.
- For legacy systems using `scrypt`, use a minimum CPU/memory cost parameter of (2^16), a minimum block size of 8 (1024 bytes), and a parallelization parameter of 1.
- If `FIPS-140` compliance is required, use `PBKDF2` with a work factor of 310,000 or more and set with an internal hash function of `HMAC-SHA-256`.
- Consider using a pepper to provide additional defense in depth (though alone, it provides no additional secure characteristics).

All the options are designed to be computationally intensive.

> This back-of-the-envelope calculation should make it clear that using a randomly-generated
> password provides you, as a user, with a significant level of protection against brute-force
> attacks even if the server is using fast hashing algorithms for password storage.
> Consistent usage of a password manager is indeed one of the easiest ways to boost your security profile.

## Salting

- `Argon2` is a lot slower than `SHA-3` but this is not enough to make a dictionary attack unfeasible.
- It takes longer to hash the most common 10 million passwords

**salting** is where we add a _unique_ random string to the password before the hash

- The **salt** is stored next to the password hash, in our database.
- If an attacker gets their hands on a databse backup, they will have access to all **salts**.
- But even with access to the **salts**, they'll still have to re-compute; `dictionary_size * n_users`

- OWASP recommends an additional layer of defence - **peppering**
  - All hashes stored in the database are encrypted using a shared secret, only known to the application.
  - However, encryption brings forth another set of challenges:
    - where are we going to store the key?
    - How do we rotate it?
    - Usually a Hardware Security Module (HSM) or a secret vault is used

## PHC String Format

The PHC string format provides a standard representation for a password hash: it includes the hash itself, the salt, the algorithm and all its associated parameters.

It's a great alternative to constantly keeping the algorithm and hash up to date.

Example:

```sh
# ${algorithm}${algorithm version}${$-separated algorithm parameters}${hash}${salt}
$argon2id$v=19$m=65536,t=2,p=1$gZiV/M1gPc22ElAH/Jh1Hw$CWOrkoo7oJBQ/iyh7uJ0LO2aLEfrHwTWllSAxT0zRno
```

> `PasswordVerifier::verify_password` does one more thing - it leans on Output to compare the two hashes, instead of working with raw bytes.

## Do Not Block the Async Executor

**infamous blocking problem**

`async/await` in Rust is built around concept called **cooperative scheduling**

Example:

```rust
async fn my_fn() {
  a().await;
  b().await;
  c().await;
}
```

- `my_fn()` returns a future
- When the future is _awaited_, our async runtime (tokio) enters into the picture: it starts polling it

How is **poll** implemented for the **Future** returned by `my_fn()`?

You can think of it as a state machine:

```rust
enum MyFnFuture {
  Intialized,
  CallingA,
  CallingB,
  CallingC,
  Complete
}
```

- Every time _poll_ is called, it tries to make progress by reaching the next state.

I think async Rust is similar to async JavaScript where the functions actually pause execution and resume later.

- `tokio` manages to make progress _concurrently_ on multiple tasks - by continuously parking an resuming each of them.
- **poll** is expected to be fast - it should return in less than 10-100 microseconds.
- If it takes longer than ~100 microseconds, than that's when you say _"a task is blocking the executor/the async thread"_

- For CPU intensive workloads that take longer than 1ms you should use `tokio::task::spawn_blocking`
- Those threads are reserved for blocking operations and do not interfere with the scheduling async tasks.

## ðŸ“¦ Used

- [base64](https://crates.io/crates/base64)
- [sha3](https://crates.io/crates/sha3)

## References

- [how many passwords average person](https://tech.co/password-managers/how-many-passwords-average-person)
- [how to fake a fingerprint and break into a phone](https://www.youtube.com/watch?v=tj2Ty7WkGqk)
- [Pefect Hash Function](https://en.wikipedia.org/wiki/Perfect_hash_function)
- [PHC String Format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md#specification)
- [Async: What is blocking?](https://ryhl.io/blog/async-what-is-blocking/)
